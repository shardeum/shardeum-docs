---
title: Transaction Lifcycle
description: Learn Shardeum's transaction lifecycle
---


### 1. Overview

The transaction lifecycle in the network encompasses both protocol-level transactions, which maintain network cycles and handle consensus, and user transactions, which include coin transfers and smart contract interactions. User transactions are particularly significant for measuring transactions per second (TPS), as these are the interactions that most users care about. Unlike some other networks that count internal transactions towards TPS, this network only counts user transactions to provide an honest metric.

### 2. Transaction Initiation

* **User Intent**: The lifecycle begins when a user expresses intent to perform a transaction, such as a coin transfer or interacting with a smart contract, via a wallet like MetaMask.
* **RPC Server Interaction**: The user's transaction request is sent to an RPC (Remote Procedure Call) server, which acts as the Ethereum standard interface to submit transactions to the network and handle various network queries. The RPC server connects the user's wallet to the network.

### 3. Transaction Submission

* **Nonce and Gas Estimation**: The RPC server fetches the nonce (a sequential number to keep transactions in order) and estimates the gas required for the transaction. The gas estimate involves simulating the transaction on a local data RPC server with all account data to predict the computational resources needed. For smart contracts, they are pre-run to tally up all the opcodes and their gas, which gives a detailed gas estimate. A feature called "nonce mode" ensures smoother transaction handling. If a user sends a transaction with a higher nonce than expected, instead of instant rejection, the network keeps these transactions until the nonces catch up. For example, if the account nonce is five, and the user sends a transaction with nonce ten, it is kept in the queue until nonces six to nine are processed. This ensures that once nonce nine is processed, nonce ten is automatically injected by the validator network, greatly improving user experience. More about the technical side of things can be seen at [`addTransactionToNonceQueue()`](https://github.com/shardeum/shardus-core/blob/e8c14ce4ba19785145646e840082acb57ec8ce3b/src/state-manager/TransactionQueue.ts#L982).
* **Signing and Sending**: Once the nonce and gas details are confirmed, the user signs the transaction with their private key in MetaMask. The signed transaction is then submitted from MetaMask to the RPC server, which injects the transaction into the validator network.

![Transaction Submission](/img/new/i4.jpg)

### 4. Transaction Processing

* **Transaction Lifecycle States**: A transaction goes through a lifecycle resembling a state machine. It starts in a waiting state after being injected into the network. This waiting state lasts about six seconds, allowing the transaction to mature. During this time, it is queued by multiple validators who need to process it. The six-second wait ensures that transactions are ordered correctly based on timestamps. Once the six seconds have passed, the transaction can be processed.
* **Validator Network**: The transaction is initially sent to one active validator. This validator then propagates the transaction to other validators in the transaction group. Each validator in the group holds a part of the transaction data necessary for processing. For example, if a transaction requires access to account data for accounts A, B, and C, then each of these accounts will have its own consensus group. Let's say there is a consensus group for account A, a consensus group for account B, and a consensus group for account C. Together, these three consensus groups form a transaction group. Each validator within these consensus groups collaborates to process the transaction. These consensus groups can be perfectly or partially overlapped, ensuring flexibility and efficiency in transaction processing. The forwarding of a transaction is executed in [`forwardTransactionToLuckyNodes()`](https://github.com/shardeum/shardus-core/blob/e8c14ce4ba19785145646e840082acb57ec8ce3b/src/shardus/index.ts#L1566).
* **Execution Group Selection**: During the waiting data phase, a special system is used to pick only one group to execute the transaction. This is because executing the transaction in every single shard offers no benefit. The network has determined that 128 nodes are secure enough to determine the value of a transaction. However, the shard executing the transaction may not have all necessary information for accounts B and C. The function that enqueues and choses the execution group is [`routeAndQueueAcceptedTransaction()`](https://github.com/shardeum/shardus-core/blob/e8c14ce4ba19785145646e840082acb57ec8ce3b/src/state-manager/TransactionQueue.ts#L1810).

![Transaction Submission](/img/new/i5.jpg)

* **Transaction Group Dynamics**: Validators use a "corresponding tell" process to efficiently share data needed for transaction processing. For instance, if Account B's data is required by an execution group, nodes in Account B's consensus group will forward this data to the nodes in the execution group. This process is designed to be efficient and secure, preventing any single node from unduly influencing the transaction by ensuring data is only forwarded to a specific node as defined by sharding math. The sending of this message is done in [`tellCorrespondingNodes()`](https://github.com/shardeum/shardus-core/blob/e8c14ce4ba19785145646e840082acb57ec8ce3b/src/state-manager/TransactionQueue.ts#L3930).
* **Consensus Formation**: Validators run the transaction through their state machine, apply it to their local state, and form a consensus on the transactionâ€™s result. They each create a vote based on whether the transaction is valid, eventually producing a receipt that indicates if the transaction was approved or rejected. The producing of the receipt can be found at [`tryProduceReceipt()`](https://github.com/shardeum/shardus-core/blob/e8c14ce4ba19785145646e840082acb57ec8ce3b/src/state-manager/TransactionConsensus.ts#L1348). For example, in a simple consensus process, each node shares its vote with the others. These votes are then compressed into a single hash. If a majority of the nodes agree and have the same hash, the transaction is confirmed. This hash is cryptographically signed, creating a provable receipt. If a validator sees that a majority of other nodes have the same hash, it acknowledges the consensus and confirms the transaction receipt. The creating of a vote is located in [`createAndShareVote()`](https://github.com/shardeum/shardus-core/blob/e8c14ce4ba19785145646e840082acb57ec8ce3b/src/state-manager/TransactionConsensus.ts#L2531), as well as the appending of it to the list of votes in [`tryAppendMessage()`](https://github.com/shardeum/shardus-core/blob/e8c14ce4ba19785145646e840082acb57ec8ce3b/src/state-manager/TransactionConsensus.ts#L2812).
* **Commit Phase**: Once the receipt is created and the transaction is confirmed, validators proceed to commit the receipt. This involves reversing the data sharing process, where nodes that received account data for execution send updated data back to the original nodes. This ensures that all nodes in the transaction group have the correct and updated account states. This phase is expressed as code in [`commitConsensedTransaction()`](https://github.com/shardeum/shardus-core/blob/e8c14ce4ba19785145646e840082acb57ec8ce3b/src/state-manager/TransactionQueue.ts#L1392).
* **Gossip Protocol**: The network employs a gossip protocol to e1nsure all nodes in the transaction group receive the transaction efficiently. This protocol optimizes communication by sending messages to a few nodes, which then propagate the message further, reducing the load on any single node. The function that sends the gossip message is [`shareAppliedReceipt()`](https://github.com/shardeum/shardus-core/blob/e8c14ce4ba19785145646e840082acb57ec8ce3b/src/state-manager/TransactionConsensus.ts#L1117).
* The main function the processes transactions is [`processTransactions()`](https://github.com/shardeum/shardus-core/blob/e8c14ce4ba19785145646e840082acb57ec8ce3b/src/state-manager/TransactionQueue.ts#L4623).

![Validator Stages](/img/new/i6.jpg)

### 5. Data Distribution and State Updates

* **Transaction Receipt:** The transaction receipt is sent to an archiver, a specialized node responsible for long-term storage and data integrity. The archiver performs robust queries to the validator network to validate the receipt, ensuring data integrity before storing it. The sending is done in [`addReceiptToForward()`](https://github.com/shardeum/shardus-core/blob/e8c14ce4ba19785145646e840082acb57ec8ce3b/src/state-manager/TransactionQueue.ts#L6630).
* **Archiver Setup**: Once the archiver approves the transaction receipt, it writes the receipt to a data log for inter-process communication and also stores it in a database. This database is not highly optimized for queries but is efficient for storage purposes. It is crucial that valid receipts make it to an Archive Server, as failing to do so can cause serious issues. To prevent this, the network ensures that someone involved with the receipt ensures its successful ingestion into an archiver.
* **Data Forwarding Mechanism**: The archiver forwards the receipt to a distributor, which disseminates the transaction data to a collector. Distributors use WebSockets to send data efficiently to collectors, ensuring real-time updates across the network. The collector then sends the data back to the local data RPC server, which notifies MetaMask, which is polling, that the transaction has been completed. Once MetaMask receives the confirmation, it updates the user on the transaction status.
* **Data Syncing**: The archiver also forwards transaction data to an explorer collector, which updates the blockchain explorer. This allows users and developers to independently verify transaction status through the explorer interface.
* **State Updates**: Validators maintain only the latest state to optimize performance, while archivers store historical state data. This separation ensures efficient access to current data while preserving the ability to audit and review past transactions.
* **Distributor and Collector Mechanism**: The distributor, a microservice, reads the data log and continuously pulls in data. Collectors connected to distributors receive a constant stream of transactions and their updated states.
* **Flexible Topologies**: The system supports various topologies, allowing for operational flexibility. For instance, one archiver can connect to multiple collectors, or a collector can link to several distributors. This flexibility ensures that the network can scale effectively, addressing potential overloads in the main net.
* **Efficiency of State Updates**: Validators only store the latest state to ensure quick access and high performance, relying on archivers for historical data retrieval when necessary.

![Network Stages](/img/new/i7.jpg)